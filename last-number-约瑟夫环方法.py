'''
假设我们用 f(2k)f(2k) 表示初始时 n=2kn=2k 个数字最后剩下的编号，那么绿色部分重新编号后最后剩下的数字就是 f(k)f(k) 。但是怎么将 f(k)f(k) 重新映射回绿色的数字编号呢？

通过观察我们可以发现，绿色数字整除 22 ，再加上蓝色的映射后的编号，结果一定等于 k+1k+1 。所以我们就得到了映射回去的公式：

f(2k) = 2(k+1-f(k))
f(2k)=2(k+1−f(k))

比如说你求出来 f(k) = 2f(k)=2 ，也就是蓝色部分最后剩下的数字是 22 ，那么映射成绿色的编号就是 2k-22k−2 ，这就是最初的编号了。
如果 n=2k+1n=2k+1 ，那么如上图所示，只需要在后面加个橙色的 2k+12k+1 就行了。

但是第一轮的时候它就被消除了，所以绿色的剩下的编号和之前偶数情况没有任何区别。所以最终的答案也是：

f(2k+1) = 2(k+1-f(k))
f(2k+1)=2(k+1−f(k))

最后发现奇偶情况下，公式其实可以统一起来，用 nn 来替换 kk 就得到了：

f(n) = 2\left(\left\lfloor\frac{n}{2}\right\rfloor-f\left(\left\lfloor\frac{n}{2}\right\rfloor\right)\right)
f(n)=2(⌊ 2n ⌋−f(⌊ 2n⌋))

'''


def lastRemaining(n):
    return 1 if n ==1 else 2*(n//2+1-lastRemaining(n//2))

print(lastRemaining(9))